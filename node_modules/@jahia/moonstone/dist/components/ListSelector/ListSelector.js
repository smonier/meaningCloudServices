import _extends from "@babel/runtime/helpers/extends";
import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _objectWithoutProperties from "@babel/runtime/helpers/objectWithoutProperties";
var _excluded = ["label", "options", "values", "isReadOnly", "onChange"];

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/* Disabled lint due to incompatibility of Button with regular props, work on this is in progress */

/* eslint-disable-next-line @typescript-eslint/ban-ts-comment */
// @ts-nocheck
import React, { useState } from 'react';
import { ValueList } from "./ValueList";
import { Button, Typography } from "./..";
import { ChevronDoubleLeft, ChevronDoubleRight, ChevronRight, Close } from "../../icons";
import "./ListSelector.css";
import clsx from 'clsx';
var MLRS_DRAG = 'mlrs_drag_list_item';
export var ListSelector = function ListSelector(_ref) {
  var _ref$label = _ref.label,
      label = _ref$label === void 0 ? {
    addAllTitle: 'Add all',
    removeAllTitle: 'Remove all',
    selected: '0 items selected'
  } : _ref$label,
      _ref$options = _ref.options,
      options = _ref$options === void 0 ? [] : _ref$options,
      _ref$values = _ref.values,
      values = _ref$values === void 0 ? [] : _ref$values,
      isReadOnly = _ref.isReadOnly,
      onChange = _ref.onChange,
      props = _objectWithoutProperties(_ref, _excluded);

  var _useState = useState(null),
      _useState2 = _slicedToArray(_useState, 2),
      dragged = _useState2[0],
      setDragged = _useState2[1]; // This tracks drag operation without delay and prevents NPE, if we ever experience issues with this, 'dragged' will need to live in this ref
  // like it did before, but so far state updates are pretty fast and I did not see any issues.


  var _useState3 = useState(null),
      _useState4 = _slicedToArray(_useState3, 2),
      filterLeft = _useState4[0],
      setFilterLeft = _useState4[1];

  var _useState5 = useState(null),
      _useState6 = _slicedToArray(_useState5, 2),
      filterRight = _useState6[0],
      setFilterRight = _useState6[1];

  var valuesLeft = options.filter(function (o) {
    return !values.includes(o.value);
  }).filter(function (v) {
    return !filterLeft || filterLeft === '' || v.label.toLowerCase().indexOf(filterLeft.toLowerCase()) !== -1;
  });
  var valuesRight = values.map(function (v) {
    return options.find(function (o) {
      return o.value === v;
    });
  }).filter(function (v) {
    return !filterRight || filterRight === '' || v.label.toLowerCase().indexOf(filterRight.toLowerCase()) !== -1;
  });

  if (typeof (dragged === null || dragged === void 0 ? void 0 : dragged.originalIndex) === 'number') {
    valuesRight.splice(dragged.originalIndex, 1);
  } // Add left side item to right side without triggering on change so its space is kept in the left list but can also exist in right list


  if (typeof (dragged === null || dragged === void 0 ? void 0 : dragged.index) === 'number') {
    valuesRight.splice(dragged.index, 0, _objectSpread(_objectSpread({}, dragged.value), {}, {
      tempItem: typeof dragged.originalIndex !== 'number'
    }));
  }

  return /*#__PURE__*/React.createElement("div", _extends({
    className: clsx('flexRow_nowrap', 'moonstone-multipleSelector')
  }, props), /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement(ValueList, {
    values: valuesLeft,
    role: "left-list",
    iconEnd: /*#__PURE__*/React.createElement(ChevronRight, {
      className: "moonstone-displayNone"
    }),
    isReadOnly: isReadOnly,
    filter: filterLeft,
    setFilter: setFilterLeft,
    listClasses: typeof (dragged === null || dragged === void 0 ? void 0 : dragged.originalIndex) === 'number' ? ['moonstone-draggedOver'] : [],
    draggedId: dragged === null || dragged === void 0 ? void 0 : dragged.value.value,
    onClick: function onClick(e, value) {
      onChange(values.concat(value.value));
    },
    onDragStart: function onDragStart(e, value) {
      e.stopPropagation();
      var ct = e.currentTarget;
      setTimeout(function () {
        ct.parentNode.parentNode.style.opacity = '0';
      }, 10);
      e.dataTransfer.setData(MLRS_DRAG, JSON.stringify({
        type: MLRS_DRAG,
        value: value
      }));
      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.setDragImage(e.currentTarget.parentNode.parentNode, 10, 10);
      setDragged({
        value: value,
        from: 'left'
      });
    },
    onDragEnd: function onDragEnd(e) {
      e.stopPropagation();
      e.currentTarget.parentNode.parentNode.style.opacity = '1';
      setDragged(null);
    },
    onDragOver: function onDragOver(e) {
      e.stopPropagation();

      if (e.dataTransfer.types.includes(MLRS_DRAG)) {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
      }
    },
    onDrop: function onDrop(e) {
      e.stopPropagation();

      if (e.dataTransfer.types.includes(MLRS_DRAG)) {
        onChange(values.filter(function (val) {
          return val !== dragged.value.value;
        }));
        setDragged(null);
      }
    }
  })), /*#__PURE__*/React.createElement("div", {
    className: "moonstone-buttonSection"
  }, /*#__PURE__*/React.createElement("div", {
    className: "moonstone-buttons"
  }, /*#__PURE__*/React.createElement(Button, {
    title: label.addAllTitle,
    role: "add-all",
    variant: "ghost",
    isDisabled: isReadOnly || valuesLeft.length === 0,
    icon: /*#__PURE__*/React.createElement(ChevronDoubleRight, null),
    onClick: function onClick() {
      return onChange([].concat(_toConsumableArray(valuesRight), _toConsumableArray(valuesLeft)).map(function (o) {
        return o.value;
      }));
    }
  }), /*#__PURE__*/React.createElement(Button, {
    title: label.removeAllTitle,
    role: "remove-all",
    variant: "ghost",
    isDisabled: isReadOnly || valuesRight.length === 0,
    icon: /*#__PURE__*/React.createElement(ChevronDoubleLeft, null),
    onClick: function onClick() {
      return onChange(values.filter(function (v) {
        return !valuesRight.find(function (o) {
          return o.value === v;
        });
      }));
    }
  }))), /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement(ValueList, {
    values: valuesRight,
    role: "right-list",
    iconEnd: /*#__PURE__*/React.createElement(Close, {
      className: "moonstone-displayNone"
    }),
    isReadOnly: isReadOnly,
    label: label,
    filter: filterRight,
    setFilter: setFilterRight,
    listClasses: dragged && !filterRight ? ['moonstone-draggedOver'] : [],
    draggedId: dragged === null || dragged === void 0 ? void 0 : dragged.value.value,
    onClick: function onClick(e, value) {
      onChange(values.filter(function (val) {
        return val !== value.value;
      }));
    },
    onDragStart: function onDragStart(e, value) {
      e.stopPropagation();
      var ct = e.currentTarget;
      setTimeout(function () {
        ct.parentNode.parentNode.style.opacity = '0';
      }, 10);
      e.dataTransfer.setData(MLRS_DRAG, JSON.stringify({
        type: MLRS_DRAG,
        value: value
      }));
      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.setDragImage(e.currentTarget.parentNode.parentNode, 10, 10);
      setDragged({
        value: value,
        originalIndex: valuesRight.indexOf(value),
        index: valuesRight.indexOf(value),
        from: 'right'
      });
    },
    onDragEnd: function onDragEnd(e) {
      e.stopPropagation();
      e.currentTarget.parentNode.parentNode.style.opacity = '1';
      setDragged(null);
    },
    onDragOver: function onDragOver(e) {
      e.stopPropagation(); // Perform move of the item within the list

      if (e.dataTransfer.types.includes(MLRS_DRAG) && !filterRight) {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
        var rect = e.currentTarget.getBoundingClientRect();
        var clientOffset = {
          x: e.clientX,
          y: e.clientY
        };
        var targetMidPointY = rect.y + rect.height / 2;
        var newIndex = -1;

        if (value && dragged.value.value !== value.value) {
          if (clientOffset.y < targetMidPointY) {
            newIndex = valuesRight.filter(function (f) {
              return f.value !== dragged.value.value;
            }).indexOf(value);
          } // Avoid triggering change for adjacent target


          if (clientOffset.y > targetMidPointY) {
            newIndex = valuesRight.filter(function (f) {
              return f.value !== dragged.value.value;
            }).indexOf(value) + 1;
          }
        } else if (!value) {
          newIndex = valuesRight.length;
        }

        if (newIndex !== -1 && dragged.index !== newIndex) {
          setDragged(function (state) {
            return _objectSpread(_objectSpread({}, state), {}, {
              index: newIndex
            });
          });
        }
      }
    },
    onDrop: function onDrop(e) {
      // Confirms drop and prevents reordering onDragEnd
      e.stopPropagation();

      if (e.dataTransfer.types.includes(MLRS_DRAG)) {
        onChange(valuesRight.map(function (v) {
          return v.value;
        }));
        setDragged(null);
      }
    }
  }), /*#__PURE__*/React.createElement("div", {
    className: "moonstone-captionContainer"
  }, /*#__PURE__*/React.createElement(Typography, {
    variant: "caption",
    weight: "semiBold"
  }, values.length > 0 && label.selected))));
};
ListSelector.displayName = 'ListSelector';
//# sourceMappingURL=ListSelector.js.map

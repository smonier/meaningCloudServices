import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import _extends from "@babel/runtime/helpers/extends";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _pt from "prop-types";
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
import React, { useEffect, useMemo, useReducer, useRef } from 'react';
import ReactDOM from 'react-dom';
import { DisplayActions } from "../core";
var ItemLoading = function ItemLoading(props) {
  var _props$context$props = _objectSpread(_objectSpread({}, props.context), props),
    id = _props$context$props.id,
    parentMenuContext = _props$context$props.parentMenuContext,
    MenuItemRenderer = _props$context$props.menuItemRenderer;
  useEffect(function () {
    parentMenuContext.dispatch({
      type: 'loading',
      item: id
    });
  });
  return /*#__PURE__*/React.createElement(MenuItemRenderer, _extends({}, props, {
    onClick: function onClick() {
      //
    }
  }));
};
ItemLoading.propTypes = {
  id: _pt.string.isRequired,
  context: _pt.object,
  parentMenuContext: _pt.shape({
    id: _pt.string.isRequired,
    dispatch: _pt.func.isRequired,
    display: _pt.func.isRequired
  })
};
var ItemRender = function ItemRender(props) {
  var _props$context$props2 = _objectSpread(_objectSpread({}, props.context), props),
    id = _props$context$props2.id,
    _onClick = _props$context$props2.onClick,
    menuContext = _props$context$props2.menuContext,
    menuState = _props$context$props2.menuState,
    rootMenuContext = _props$context$props2.rootMenuContext,
    parentMenuContext = _props$context$props2.parentMenuContext,
    MenuItemRenderer = _props$context$props2.menuItemRenderer,
    isVisible = _props$context$props2.isVisible;
  useEffect(function () {
    parentMenuContext.dispatch({
      type: 'loaded',
      item: id,
      isVisible: isVisible
    });
  });

  // Values for menuContext / menuState are set only if this item is a submenu item.

  if (isVisible === false) {
    return null;
  }
  return /*#__PURE__*/React.createElement(MenuItemRenderer, _extends({}, props, {
    onClick: function onClick(event) {
      // Call the action and close the menu
      if (_onClick) {
        _onClick(props, event);
        event.stopPropagation();
        rootMenuContext.dispatch({
          type: 'close'
        });
      }
    },
    onMouseEnter: function onMouseEnter(event) {
      if (menuContext) {
        // Open submenu (only if it's not opened already)
        if (menuState && !menuState.isOpen) {
          var c = event.currentTarget.getBoundingClientRect();
          menuContext.display(null, {
            anchorEl: {
              getBoundingClientRect: function getBoundingClientRect() {
                return c;
              }
            },
            anchorElOrigin: {
              vertical: 'top',
              horizontal: 'right'
            }
          });
        }
      } else {
        // Moved into another menu item (not sub menu), close current submenu if present
        parentMenuContext.dispatch({
          type: 'setSubMenuContext',
          value: null
        });
      }
    },
    onMouseLeave: function onMouseLeave() {
      // Check if the mouse moved out of the item, without going into the sub menu.
      if (menuContext) {
        setTimeout(function () {
          menuContext.dispatch({
            type: 'leaveItem'
          });
        }, 100);
      }
    }
  }));
};
ItemRender.propTypes = {
  context: _pt.object,
  id: _pt.string.isRequired,
  rootMenuContext: _pt.shape({
    id: _pt.string.isRequired,
    dispatch: _pt.func.isRequired,
    display: _pt.func.isRequired
  }),
  parentMenuContext: _pt.shape({
    id: _pt.string.isRequired,
    dispatch: _pt.func.isRequired,
    display: _pt.func.isRequired
  }),
  menuContext: _pt.shape({
    id: _pt.string.isRequired,
    dispatch: _pt.func.isRequired,
    display: _pt.func.isRequired
  }),
  menuState: _pt.shape({
    id: _pt.string.isRequired,
    currentCtx: _pt.oneOfType([_pt.object, _pt.shape({
      originalContext: _pt.object
    })]).isRequired,
    anchor: _pt.shape({
      anchorEl: _pt.any,
      anchorPosition: _pt.shape({
        top: _pt.number.isRequired,
        left: _pt.number.isRequired
      }),
      anchorElOrigin: _pt.shape({
        horizontal: _pt.oneOf(['left', 'center', 'right']).isRequired,
        vertical: _pt.oneOf(['top', 'center', 'bottom']).isRequired
      }),
      transformElOrigin: _pt.shape({
        horizontal: _pt.oneOf(['left', 'right']).isRequired,
        vertical: _pt.oneOf(['top', 'bottom']).isRequired
      })
    }).isRequired,
    isRendered: _pt.bool.isRequired,
    isOpen: _pt.bool.isRequired,
    isInMenu: _pt.bool.isRequired,
    isSubMenu: _pt.bool.isRequired,
    subMenuContext: _pt.shape({
      id: _pt.string.isRequired,
      dispatch: _pt.func.isRequired,
      display: _pt.func.isRequired
    }),
    loadingItems: _pt.arrayOf(_pt.string).isRequired,
    loadedItems: _pt.arrayOf(_pt.string).isRequired
  }),
  onClick: _pt.func,
  isVisible: _pt.bool
};
var Menu = function Menu(props) {
  var menuTarget = props.menuTarget,
    menuFilter = props.menuFilter,
    isMenuPreload = props.isMenuPreload,
    MenuRenderer = props.menuRenderer,
    menuItemRenderer = props.menuItemRenderer,
    rootMenuContext = props.rootMenuContext,
    originalContext = props.originalContext,
    id = props.id,
    actionKey = props.actionKey,
    menuContext = props.menuContext,
    menuState = props.menuState,
    menuItemProps = props.menuItemProps;
  return /*#__PURE__*/React.createElement(MenuRenderer, {
    id: id,
    context: _objectSpread({
      key: props.id
    }, props),
    menuKey: actionKey,
    isSubMenu: menuState.isSubMenu,
    anchor: menuState.anchor,
    isLoading: menuState.loadingItems.length > 0,
    isOpen: menuState.isOpen,
    onMouseEnter: function onMouseEnter() {
      menuContext.dispatch({
        type: 'enterMenu'
      });
    },
    onMouseLeave: function onMouseLeave() {
      menuContext.dispatch({
        type: 'leaveMenu'
      });
    },
    onClose: function onClose(e) {
      e.preventDefault();
      e.stopPropagation();
      menuContext.dispatch({
        type: 'close'
      });
    },
    onExited: function onExited() {
      if (!isMenuPreload) {
        menuContext.dispatch({
          type: 'destroy'
        });
      }
    }
  }, /*#__PURE__*/React.createElement(DisplayActions, _extends({}, originalContext, {
    id: id,
    target: menuTarget,
    filter: menuFilter,
    buttonProps: menuItemProps,
    menuRenderer: MenuRenderer,
    menuItemRenderer: menuItemRenderer,
    parentMenuContext: menuContext,
    rootMenuContext: rootMenuContext,
    loading: ItemLoading,
    render: ItemRender
  })));
};
Menu.propTypes = {
  id: _pt.string.isRequired,
  actionKey: _pt.string.isRequired,
  menuItemProps: _pt.object,
  isMenuPreload: _pt.bool,
  menuTarget: _pt.string.isRequired,
  menuFilter: _pt.func,
  isMenuUseEventPosition: _pt.bool,
  buttonIcon: _pt.element,
  originalContext: _pt.object,
  rootMenuContext: _pt.shape({
    id: _pt.string.isRequired,
    dispatch: _pt.func.isRequired,
    display: _pt.func.isRequired
  }),
  parentMenuContext: _pt.shape({
    id: _pt.string.isRequired,
    dispatch: _pt.func.isRequired,
    display: _pt.func.isRequired
  }),
  menuContext: _pt.shape({
    id: _pt.string.isRequired,
    dispatch: _pt.func.isRequired,
    display: _pt.func.isRequired
  }).isRequired,
  menuState: _pt.shape({
    id: _pt.string.isRequired,
    currentCtx: _pt.oneOfType([_pt.object, _pt.shape({
      originalContext: _pt.object
    })]).isRequired,
    anchor: _pt.shape({
      anchorEl: _pt.any,
      anchorPosition: _pt.shape({
        top: _pt.number.isRequired,
        left: _pt.number.isRequired
      }),
      anchorElOrigin: _pt.shape({
        horizontal: _pt.oneOf(['left', 'center', 'right']).isRequired,
        vertical: _pt.oneOf(['top', 'center', 'bottom']).isRequired
      }),
      transformElOrigin: _pt.shape({
        horizontal: _pt.oneOf(['left', 'right']).isRequired,
        vertical: _pt.oneOf(['top', 'bottom']).isRequired
      })
    }).isRequired,
    isRendered: _pt.bool.isRequired,
    isOpen: _pt.bool.isRequired,
    isInMenu: _pt.bool.isRequired,
    isSubMenu: _pt.bool.isRequired,
    subMenuContext: _pt.shape({
      id: _pt.string.isRequired,
      dispatch: _pt.func.isRequired,
      display: _pt.func.isRequired
    }),
    loadingItems: _pt.arrayOf(_pt.string).isRequired,
    loadedItems: _pt.arrayOf(_pt.string).isRequired
  })
};
function add(items, item) {
  return items.indexOf(item) === -1 ? [].concat(_toConsumableArray(items), [item]) : items;
}
function remove(items, item) {
  return items.filter(function (f) {
    return f !== item;
  });
}
var reducer = function reducer(state, action) {
  switch (action.type) {
    case 'render':
      return _objectSpread(_objectSpread({}, state), {}, {
        currentCtx: action.currentCtx ? action.currentCtx : {},
        isRendered: true
      });
    case 'destroy':
      return _objectSpread(_objectSpread({}, state), {}, {
        isRendered: false
      });
    case 'open':
      return _objectSpread(_objectSpread({}, state), {}, {
        isOpen: true,
        anchor: action.anchor
      });
    case 'close':
      return _objectSpread(_objectSpread({}, state), {}, {
        isOpen: false
      });
    case 'leaveItem':
      return _objectSpread(_objectSpread({}, state), {}, {
        isOpen: state.isInMenu
      });
    case 'enterMenu':
      return _objectSpread(_objectSpread({}, state), {}, {
        isInMenu: true
      });
    case 'leaveMenu':
      return _objectSpread(_objectSpread({}, state), {}, {
        isInMenu: false
      });
    case 'setSubMenuContext':
      {
        if (state.subMenuContext === action.value) {
          return state;
        }
        if (state.subMenuContext && state.subMenuContext !== action.value) {
          setTimeout(function () {
            state.subMenuContext.dispatch({
              type: 'close'
            });
          }, 0);
        }
        return _objectSpread(_objectSpread({}, state), {}, {
          subMenuContext: action.value
        });
      }
    case 'loading':
      return state.loadingItems.includes(action.item) || state.loadedItems.includes(action.item) ? state : _objectSpread(_objectSpread({}, state), {}, {
        loadingItems: add(state.loadingItems, action.item),
        loadedItems: remove(state.loadedItems, action.item)
      });
    case 'loaded':
      return !state.loadingItems.includes(action.item) && action.isVisible !== false === state.loadedItems.includes(action.item) ? state : _objectSpread(_objectSpread({}, state), {}, {
        loadingItems: remove(state.loadingItems, action.item),
        loadedItems: action.isVisible === false ? remove(state.loadedItems, action.item) : add(state.loadedItems, action.item)
      });
    default:
      return state;
  }
};
var MenuActionComponent = function MenuActionComponent(props) {
  var rootMenuContext = props.rootMenuContext,
    parentMenuContext = props.parentMenuContext,
    isMenuPreload = props.isMenuPreload,
    Render = props.render,
    Loading = props.loading,
    visibilityPredicate = props.visibilityPredicate;
  var id = 'actionComponent-' + props.id;
  var elRef = useRef(document.getElementById('menuHolder'));
  if (!elRef.current) {
    elRef.current = document.createElement('div');
    elRef.current.setAttribute('id', 'menuHolder');
    document.body.appendChild(elRef.current);
  }
  var _useReducer = useReducer(reducer, {
      id: id,
      isRendered: false,
      isOpen: false,
      isSubMenu: Boolean(parentMenuContext),
      isInMenu: false,
      loadingItems: [],
      loadedItems: [],
      subMenuContext: null,
      currentCtx: {},
      anchor: {
        anchorPosition: {
          top: -1000,
          left: -1000
        }
      }
    }),
    _useReducer2 = _slicedToArray(_useReducer, 2),
    menuState = _useReducer2[0],
    dispatch = _useReducer2[1];
  var menuContext = useMemo(function () {
    return {
      id: id,
      dispatch: dispatch,
      display: function display(currentCtx, anchor) {
        dispatch({
          type: 'render',
          currentCtx: currentCtx
        });
        // If there's a parent, set the current context as submenu. Previous value should be null
        if (parentMenuContext) {
          parentMenuContext.dispatch({
            type: 'setSubMenuContext',
            value: menuContext
          });
        }

        // Delay open to get animation
        setTimeout(function () {
          dispatch({
            type: 'open',
            anchor: anchor
          });
        }, 0);
      }
    };
  }, [id, parentMenuContext]);
  useEffect(function () {
    if (!menuState.isOpen && menuState.subMenuContext) {
      menuState.subMenuContext.dispatch({
        type: 'close'
      });
      dispatch({
        type: 'setSubMenuContext',
        value: null
      });
    }
  }, [id, menuState, menuContext]);
  var isVisible = !isMenuPreload || menuState.loadedItems.length > 0;
  if (visibilityPredicate) {
    isVisible = visibilityPredicate(menuState);
  }
  return /*#__PURE__*/React.createElement(React.Fragment, null, menuState.isOpen && menuState.loadingItems.length > 0 && Loading ? /*#__PURE__*/React.createElement(Loading, props) : /*#__PURE__*/React.createElement(Render, _extends({}, props, {
    menuContext: menuContext,
    menuState: menuState,
    isVisible: isVisible,
    onClick: function onClick(eventProps, event) {
      // Handle click to open menu only if not in a submenu (already handled on mouse over)
      if (!parentMenuContext) {
        if (event.currentTarget && !eventProps.isMenuUseEventPosition) {
          // Copy position of target element as it may be removed after load
          var boundingClientRect = event.currentTarget.getBoundingClientRect();
          var targetMock = _objectSpread(_objectSpread({}, event.currentTarget), {}, {
            getBoundingClientRect: function getBoundingClientRect() {
              return boundingClientRect;
            }
          });
          menuContext.display(eventProps, {
            anchorEl: targetMock,
            anchorElOrigin: {
              vertical: 'bottom',
              horizontal: 'left'
            }
          });
        } else {
          menuContext.display(eventProps, {
            anchorPosition: {
              left: event.clientX,
              top: event.clientY
            }
          });
        }
      }
    }
  })), (menuState.isRendered || isMenuPreload) && /*#__PURE__*/ReactDOM.createPortal( /*#__PURE__*/React.createElement(Menu, _extends({}, props, menuState.currentCtx.originalContext, {
    originalContext: _objectSpread(_objectSpread({}, props.originalContext), menuState.currentCtx.originalContext),
    menuContext: menuContext,
    menuState: menuState,
    rootMenuContext: rootMenuContext ? rootMenuContext : menuContext
  })), elRef.current));
};

/**
 * Context properties :
 *
 * menu : name of the target of actions to display in the menu
 * menuRenderer
 * menuItemRenderer
 */
MenuActionComponent.propTypes = {
  /**
       * Action unique id
       */
  id: _pt.string.isRequired,
  actionKey: _pt.string.isRequired,
  /**
       * Should the actions of the menu be preloaded
       */
  isMenuPreload: _pt.bool,
  /**
       * Target defining which actions to display in the menu
       */
  menuTarget: _pt.string.isRequired,
  /**
       * Filter actions to display in the menu
       */
  menuFilter: _pt.func,
  /**
       * Should the menu be displayed at the event position, or under the current element
       */
  isMenuUseEventPosition: _pt.bool,
  /**
       * Props passed to the main DisplayAction
       */
  originalContext: _pt.object,
  /**
       * Root menu context, if sub menu (internal)
       */
  rootMenuContext: _pt.shape({
    id: _pt.string.isRequired,
    dispatch: _pt.func.isRequired,
    display: _pt.func.isRequired
  }),
  /**
       * Parent menu context, if sub menu (internal)
       */
  parentMenuContext: _pt.shape({
    id: _pt.string.isRequired,
    dispatch: _pt.func.isRequired,
    display: _pt.func.isRequired
  }),
  /**
       * Helps determine if action is visible
       */
  visibilityPredicate: _pt.func
};
var menuAction = {
  component: MenuActionComponent
};
export { menuAction, MenuActionComponent };
//# sourceMappingURL=menuAction.js.map

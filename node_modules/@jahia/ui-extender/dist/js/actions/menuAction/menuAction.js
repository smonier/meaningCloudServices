"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.menuAction = exports.MenuActionComponent = void 0;
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _propTypes = _interopRequireDefault(require("prop-types"));
var _react = _interopRequireWildcard(require("react"));
var _reactDom = _interopRequireDefault(require("react-dom"));
var _core = require("../core");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
var ItemLoading = function ItemLoading(props) {
  var _props$context$props = _objectSpread(_objectSpread({}, props.context), props),
    id = _props$context$props.id,
    parentMenuContext = _props$context$props.parentMenuContext,
    MenuItemRenderer = _props$context$props.menuItemRenderer;
  (0, _react.useEffect)(function () {
    parentMenuContext.dispatch({
      type: 'loading',
      item: id
    });
  });
  return /*#__PURE__*/_react["default"].createElement(MenuItemRenderer, (0, _extends2["default"])({}, props, {
    onClick: function onClick() {
      //
    }
  }));
};
ItemLoading.propTypes = {
  id: _propTypes["default"].string.isRequired,
  context: _propTypes["default"].object,
  parentMenuContext: _propTypes["default"].shape({
    id: _propTypes["default"].string.isRequired,
    dispatch: _propTypes["default"].func.isRequired,
    display: _propTypes["default"].func.isRequired
  })
};
var ItemRender = function ItemRender(props) {
  var _props$context$props2 = _objectSpread(_objectSpread({}, props.context), props),
    id = _props$context$props2.id,
    _onClick = _props$context$props2.onClick,
    menuContext = _props$context$props2.menuContext,
    menuState = _props$context$props2.menuState,
    rootMenuContext = _props$context$props2.rootMenuContext,
    parentMenuContext = _props$context$props2.parentMenuContext,
    MenuItemRenderer = _props$context$props2.menuItemRenderer,
    isVisible = _props$context$props2.isVisible;
  (0, _react.useEffect)(function () {
    parentMenuContext.dispatch({
      type: 'loaded',
      item: id,
      isVisible: isVisible
    });
  });

  // Values for menuContext / menuState are set only if this item is a submenu item.

  if (isVisible === false) {
    return null;
  }
  return /*#__PURE__*/_react["default"].createElement(MenuItemRenderer, (0, _extends2["default"])({}, props, {
    onClick: function onClick(event) {
      // Call the action and close the menu
      if (_onClick) {
        _onClick(props, event);
        event.stopPropagation();
        rootMenuContext.dispatch({
          type: 'close'
        });
      }
    },
    onMouseEnter: function onMouseEnter(event) {
      if (menuContext) {
        // Open submenu (only if it's not opened already)
        if (menuState && !menuState.isOpen) {
          var c = event.currentTarget.getBoundingClientRect();
          menuContext.display(null, {
            anchorEl: {
              getBoundingClientRect: function getBoundingClientRect() {
                return c;
              }
            },
            anchorElOrigin: {
              vertical: 'top',
              horizontal: 'right'
            }
          });
        }
      } else {
        // Moved into another menu item (not sub menu), close current submenu if present
        parentMenuContext.dispatch({
          type: 'setSubMenuContext',
          value: null
        });
      }
    },
    onMouseLeave: function onMouseLeave() {
      // Check if the mouse moved out of the item, without going into the sub menu.
      if (menuContext) {
        setTimeout(function () {
          menuContext.dispatch({
            type: 'leaveItem'
          });
        }, 100);
      }
    }
  }));
};
ItemRender.propTypes = {
  context: _propTypes["default"].object,
  id: _propTypes["default"].string.isRequired,
  rootMenuContext: _propTypes["default"].shape({
    id: _propTypes["default"].string.isRequired,
    dispatch: _propTypes["default"].func.isRequired,
    display: _propTypes["default"].func.isRequired
  }),
  parentMenuContext: _propTypes["default"].shape({
    id: _propTypes["default"].string.isRequired,
    dispatch: _propTypes["default"].func.isRequired,
    display: _propTypes["default"].func.isRequired
  }),
  menuContext: _propTypes["default"].shape({
    id: _propTypes["default"].string.isRequired,
    dispatch: _propTypes["default"].func.isRequired,
    display: _propTypes["default"].func.isRequired
  }),
  menuState: _propTypes["default"].shape({
    id: _propTypes["default"].string.isRequired,
    currentCtx: _propTypes["default"].oneOfType([_propTypes["default"].object, _propTypes["default"].shape({
      originalContext: _propTypes["default"].object
    })]).isRequired,
    anchor: _propTypes["default"].shape({
      anchorEl: _propTypes["default"].any,
      anchorPosition: _propTypes["default"].shape({
        top: _propTypes["default"].number.isRequired,
        left: _propTypes["default"].number.isRequired
      }),
      anchorElOrigin: _propTypes["default"].shape({
        horizontal: _propTypes["default"].oneOf(['left', 'center', 'right']).isRequired,
        vertical: _propTypes["default"].oneOf(['top', 'center', 'bottom']).isRequired
      }),
      transformElOrigin: _propTypes["default"].shape({
        horizontal: _propTypes["default"].oneOf(['left', 'right']).isRequired,
        vertical: _propTypes["default"].oneOf(['top', 'bottom']).isRequired
      })
    }).isRequired,
    isRendered: _propTypes["default"].bool.isRequired,
    isOpen: _propTypes["default"].bool.isRequired,
    isInMenu: _propTypes["default"].bool.isRequired,
    isSubMenu: _propTypes["default"].bool.isRequired,
    subMenuContext: _propTypes["default"].shape({
      id: _propTypes["default"].string.isRequired,
      dispatch: _propTypes["default"].func.isRequired,
      display: _propTypes["default"].func.isRequired
    }),
    loadingItems: _propTypes["default"].arrayOf(_propTypes["default"].string).isRequired,
    loadedItems: _propTypes["default"].arrayOf(_propTypes["default"].string).isRequired
  }),
  onClick: _propTypes["default"].func,
  isVisible: _propTypes["default"].bool
};
var Menu = function Menu(props) {
  var menuTarget = props.menuTarget,
    menuFilter = props.menuFilter,
    isMenuPreload = props.isMenuPreload,
    MenuRenderer = props.menuRenderer,
    menuItemRenderer = props.menuItemRenderer,
    rootMenuContext = props.rootMenuContext,
    originalContext = props.originalContext,
    id = props.id,
    actionKey = props.actionKey,
    menuContext = props.menuContext,
    menuState = props.menuState,
    menuItemProps = props.menuItemProps;
  return /*#__PURE__*/_react["default"].createElement(MenuRenderer, {
    id: id,
    context: _objectSpread({
      key: props.id
    }, props),
    menuKey: actionKey,
    isSubMenu: menuState.isSubMenu,
    anchor: menuState.anchor,
    isLoading: menuState.loadingItems.length > 0,
    isOpen: menuState.isOpen,
    onMouseEnter: function onMouseEnter() {
      menuContext.dispatch({
        type: 'enterMenu'
      });
    },
    onMouseLeave: function onMouseLeave() {
      menuContext.dispatch({
        type: 'leaveMenu'
      });
    },
    onClose: function onClose(e) {
      e.preventDefault();
      e.stopPropagation();
      menuContext.dispatch({
        type: 'close'
      });
    },
    onExited: function onExited() {
      if (!isMenuPreload) {
        menuContext.dispatch({
          type: 'destroy'
        });
      }
    }
  }, /*#__PURE__*/_react["default"].createElement(_core.DisplayActions, (0, _extends2["default"])({}, originalContext, {
    id: id,
    target: menuTarget,
    filter: menuFilter,
    buttonProps: menuItemProps,
    menuRenderer: MenuRenderer,
    menuItemRenderer: menuItemRenderer,
    parentMenuContext: menuContext,
    rootMenuContext: rootMenuContext,
    loading: ItemLoading,
    render: ItemRender
  })));
};
Menu.propTypes = {
  id: _propTypes["default"].string.isRequired,
  actionKey: _propTypes["default"].string.isRequired,
  menuItemProps: _propTypes["default"].object,
  isMenuPreload: _propTypes["default"].bool,
  menuTarget: _propTypes["default"].string.isRequired,
  menuFilter: _propTypes["default"].func,
  isMenuUseEventPosition: _propTypes["default"].bool,
  buttonIcon: _propTypes["default"].element,
  originalContext: _propTypes["default"].object,
  rootMenuContext: _propTypes["default"].shape({
    id: _propTypes["default"].string.isRequired,
    dispatch: _propTypes["default"].func.isRequired,
    display: _propTypes["default"].func.isRequired
  }),
  parentMenuContext: _propTypes["default"].shape({
    id: _propTypes["default"].string.isRequired,
    dispatch: _propTypes["default"].func.isRequired,
    display: _propTypes["default"].func.isRequired
  }),
  menuContext: _propTypes["default"].shape({
    id: _propTypes["default"].string.isRequired,
    dispatch: _propTypes["default"].func.isRequired,
    display: _propTypes["default"].func.isRequired
  }).isRequired,
  menuState: _propTypes["default"].shape({
    id: _propTypes["default"].string.isRequired,
    currentCtx: _propTypes["default"].oneOfType([_propTypes["default"].object, _propTypes["default"].shape({
      originalContext: _propTypes["default"].object
    })]).isRequired,
    anchor: _propTypes["default"].shape({
      anchorEl: _propTypes["default"].any,
      anchorPosition: _propTypes["default"].shape({
        top: _propTypes["default"].number.isRequired,
        left: _propTypes["default"].number.isRequired
      }),
      anchorElOrigin: _propTypes["default"].shape({
        horizontal: _propTypes["default"].oneOf(['left', 'center', 'right']).isRequired,
        vertical: _propTypes["default"].oneOf(['top', 'center', 'bottom']).isRequired
      }),
      transformElOrigin: _propTypes["default"].shape({
        horizontal: _propTypes["default"].oneOf(['left', 'right']).isRequired,
        vertical: _propTypes["default"].oneOf(['top', 'bottom']).isRequired
      })
    }).isRequired,
    isRendered: _propTypes["default"].bool.isRequired,
    isOpen: _propTypes["default"].bool.isRequired,
    isInMenu: _propTypes["default"].bool.isRequired,
    isSubMenu: _propTypes["default"].bool.isRequired,
    subMenuContext: _propTypes["default"].shape({
      id: _propTypes["default"].string.isRequired,
      dispatch: _propTypes["default"].func.isRequired,
      display: _propTypes["default"].func.isRequired
    }),
    loadingItems: _propTypes["default"].arrayOf(_propTypes["default"].string).isRequired,
    loadedItems: _propTypes["default"].arrayOf(_propTypes["default"].string).isRequired
  })
};
function add(items, item) {
  return items.indexOf(item) === -1 ? [].concat((0, _toConsumableArray2["default"])(items), [item]) : items;
}
function remove(items, item) {
  return items.filter(function (f) {
    return f !== item;
  });
}
var reducer = function reducer(state, action) {
  switch (action.type) {
    case 'render':
      return _objectSpread(_objectSpread({}, state), {}, {
        currentCtx: action.currentCtx ? action.currentCtx : {},
        isRendered: true
      });
    case 'destroy':
      return _objectSpread(_objectSpread({}, state), {}, {
        isRendered: false
      });
    case 'open':
      return _objectSpread(_objectSpread({}, state), {}, {
        isOpen: true,
        anchor: action.anchor
      });
    case 'close':
      return _objectSpread(_objectSpread({}, state), {}, {
        isOpen: false
      });
    case 'leaveItem':
      return _objectSpread(_objectSpread({}, state), {}, {
        isOpen: state.isInMenu
      });
    case 'enterMenu':
      return _objectSpread(_objectSpread({}, state), {}, {
        isInMenu: true
      });
    case 'leaveMenu':
      return _objectSpread(_objectSpread({}, state), {}, {
        isInMenu: false
      });
    case 'setSubMenuContext':
      {
        if (state.subMenuContext === action.value) {
          return state;
        }
        if (state.subMenuContext && state.subMenuContext !== action.value) {
          setTimeout(function () {
            state.subMenuContext.dispatch({
              type: 'close'
            });
          }, 0);
        }
        return _objectSpread(_objectSpread({}, state), {}, {
          subMenuContext: action.value
        });
      }
    case 'loading':
      return state.loadingItems.includes(action.item) || state.loadedItems.includes(action.item) ? state : _objectSpread(_objectSpread({}, state), {}, {
        loadingItems: add(state.loadingItems, action.item),
        loadedItems: remove(state.loadedItems, action.item)
      });
    case 'loaded':
      return !state.loadingItems.includes(action.item) && action.isVisible !== false === state.loadedItems.includes(action.item) ? state : _objectSpread(_objectSpread({}, state), {}, {
        loadingItems: remove(state.loadingItems, action.item),
        loadedItems: action.isVisible === false ? remove(state.loadedItems, action.item) : add(state.loadedItems, action.item)
      });
    default:
      return state;
  }
};
var MenuActionComponent = function MenuActionComponent(props) {
  var rootMenuContext = props.rootMenuContext,
    parentMenuContext = props.parentMenuContext,
    isMenuPreload = props.isMenuPreload,
    Render = props.render,
    Loading = props.loading,
    visibilityPredicate = props.visibilityPredicate;
  var id = 'actionComponent-' + props.id;
  var elRef = (0, _react.useRef)(document.getElementById('menuHolder'));
  if (!elRef.current) {
    elRef.current = document.createElement('div');
    elRef.current.setAttribute('id', 'menuHolder');
    document.body.appendChild(elRef.current);
  }
  var _useReducer = (0, _react.useReducer)(reducer, {
      id: id,
      isRendered: false,
      isOpen: false,
      isSubMenu: Boolean(parentMenuContext),
      isInMenu: false,
      loadingItems: [],
      loadedItems: [],
      subMenuContext: null,
      currentCtx: {},
      anchor: {
        anchorPosition: {
          top: -1000,
          left: -1000
        }
      }
    }),
    _useReducer2 = (0, _slicedToArray2["default"])(_useReducer, 2),
    menuState = _useReducer2[0],
    dispatch = _useReducer2[1];
  var menuContext = (0, _react.useMemo)(function () {
    return {
      id: id,
      dispatch: dispatch,
      display: function display(currentCtx, anchor) {
        dispatch({
          type: 'render',
          currentCtx: currentCtx
        });
        // If there's a parent, set the current context as submenu. Previous value should be null
        if (parentMenuContext) {
          parentMenuContext.dispatch({
            type: 'setSubMenuContext',
            value: menuContext
          });
        }

        // Delay open to get animation
        setTimeout(function () {
          dispatch({
            type: 'open',
            anchor: anchor
          });
        }, 0);
      }
    };
  }, [id, parentMenuContext]);
  (0, _react.useEffect)(function () {
    if (!menuState.isOpen && menuState.subMenuContext) {
      menuState.subMenuContext.dispatch({
        type: 'close'
      });
      dispatch({
        type: 'setSubMenuContext',
        value: null
      });
    }
  }, [id, menuState, menuContext]);
  var isVisible = !isMenuPreload || menuState.loadedItems.length > 0;
  if (visibilityPredicate) {
    isVisible = visibilityPredicate(menuState);
  }
  return /*#__PURE__*/_react["default"].createElement(_react["default"].Fragment, null, menuState.isOpen && menuState.loadingItems.length > 0 && Loading ? /*#__PURE__*/_react["default"].createElement(Loading, props) : /*#__PURE__*/_react["default"].createElement(Render, (0, _extends2["default"])({}, props, {
    menuContext: menuContext,
    menuState: menuState,
    isVisible: isVisible,
    onClick: function onClick(eventProps, event) {
      // Handle click to open menu only if not in a submenu (already handled on mouse over)
      if (!parentMenuContext) {
        if (event.currentTarget && !eventProps.isMenuUseEventPosition) {
          // Copy position of target element as it may be removed after load
          var boundingClientRect = event.currentTarget.getBoundingClientRect();
          var targetMock = _objectSpread(_objectSpread({}, event.currentTarget), {}, {
            getBoundingClientRect: function getBoundingClientRect() {
              return boundingClientRect;
            }
          });
          menuContext.display(eventProps, {
            anchorEl: targetMock,
            anchorElOrigin: {
              vertical: 'bottom',
              horizontal: 'left'
            }
          });
        } else {
          menuContext.display(eventProps, {
            anchorPosition: {
              left: event.clientX,
              top: event.clientY
            }
          });
        }
      }
    }
  })), (menuState.isRendered || isMenuPreload) && /*#__PURE__*/_reactDom["default"].createPortal( /*#__PURE__*/_react["default"].createElement(Menu, (0, _extends2["default"])({}, props, menuState.currentCtx.originalContext, {
    originalContext: _objectSpread(_objectSpread({}, props.originalContext), menuState.currentCtx.originalContext),
    menuContext: menuContext,
    menuState: menuState,
    rootMenuContext: rootMenuContext ? rootMenuContext : menuContext
  })), elRef.current));
};

/**
 * Context properties :
 *
 * menu : name of the target of actions to display in the menu
 * menuRenderer
 * menuItemRenderer
 */
exports.MenuActionComponent = MenuActionComponent;
MenuActionComponent.propTypes = {
  /**
       * Action unique id
       */
  id: _propTypes["default"].string.isRequired,
  actionKey: _propTypes["default"].string.isRequired,
  /**
       * Should the actions of the menu be preloaded
       */
  isMenuPreload: _propTypes["default"].bool,
  /**
       * Target defining which actions to display in the menu
       */
  menuTarget: _propTypes["default"].string.isRequired,
  /**
       * Filter actions to display in the menu
       */
  menuFilter: _propTypes["default"].func,
  /**
       * Should the menu be displayed at the event position, or under the current element
       */
  isMenuUseEventPosition: _propTypes["default"].bool,
  /**
       * Props passed to the main DisplayAction
       */
  originalContext: _propTypes["default"].object,
  /**
       * Root menu context, if sub menu (internal)
       */
  rootMenuContext: _propTypes["default"].shape({
    id: _propTypes["default"].string.isRequired,
    dispatch: _propTypes["default"].func.isRequired,
    display: _propTypes["default"].func.isRequired
  }),
  /**
       * Parent menu context, if sub menu (internal)
       */
  parentMenuContext: _propTypes["default"].shape({
    id: _propTypes["default"].string.isRequired,
    dispatch: _propTypes["default"].func.isRequired,
    display: _propTypes["default"].func.isRequired
  }),
  /**
       * Helps determine if action is visible
       */
  visibilityPredicate: _propTypes["default"].func
};
var menuAction = {
  component: MenuActionComponent
};
exports.menuAction = menuAction;
//# sourceMappingURL=menuAction.js.map

import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _objectWithoutProperties from "@babel/runtime/helpers/objectWithoutProperties";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
var _excluded = ["data"];
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
import { useEffect, useState } from 'react';
import { useApolloClient } from '@apollo/client';
import { getQuery } from "./useNodeInfo.gql-queries";
import { getEncodedPermissionName } from "../../fragments/getPermissionFragment";
import { getEncodedNodeTypeName } from "../../fragments/getIsNodeTypeFragment";
import { SCHEMA_FIELDS_QUERY } from "../useSchemaFields/useSchemaFields.gql-queries";
import { isSubset, merge } from "./useNodeInfo.utils";
import { useMemoRequest } from "./useMemoRequest";
import deepEquals from 'fast-deep-equal';
var queue = [];
var schemaResult;
var timeout;
var observedQueries = [];
function scheduleQueue(client) {
  if (!timeout && schemaResult) {
    timeout = window.setTimeout(function () {
      timeoutHandler(client);
      clearTimeout(timeout);
      timeout = null;
    }, 0);
  }
}
var timeoutHandler = function timeoutHandler(client) {
  var mergedQueue = [];
  queue.forEach(function (request) {
    var toInsert = {
      variables: request.variables,
      queryOptions: request.queryOptions,
      options: request.options,
      originals: [request]
    };
    var mergeable = mergedQueue.find(function (q) {
      return JSON.stringify(q.queryOptions) === JSON.stringify(toInsert.queryOptions) && (isSubset(q.variables, toInsert.variables) || isSubset(toInsert.variables, q.variables));
    });
    if (mergeable) {
      merge(mergeable, toInsert);
    } else {
      mergedQueue.push({
        variables: toInsert.variables && _objectSpread({}, toInsert.variables),
        queryOptions: toInsert.queryOptions && _objectSpread({}, toInsert.queryOptions),
        options: toInsert.options && _objectSpread({}, toInsert.options),
        originals: toInsert.originals
      });
    }
  });
  observedQueries.forEach(function (obs) {
    return obs.unsubscribe();
  });
  observedQueries = [];
  mergedQueue.forEach(function (mergedRequest) {
    var variables = mergedRequest.variables,
      queryOptions = mergedRequest.queryOptions,
      options = mergedRequest.options,
      originals = mergedRequest.originals;
    var _getQuery = getQuery(variables, schemaResult, options),
      query = _getQuery.query,
      generatedVariables = _getQuery.generatedVariables,
      skip = _getQuery.skip;
    if (skip) {
      // No query to execute
      originals.forEach(function (request) {
        request.setResult({
          loading: false
        });
      });
    } else {
      var watchedQuery = client.watchQuery(_objectSpread(_objectSpread({
        query: query,
        errorPolicy: 'ignore'
      }, queryOptions), {}, {
        variables: generatedVariables
      })).subscribe(function (_ref) {
        var data = _ref.data,
          others = _objectWithoutProperties(_ref, _excluded);
        var result = getResult(data, others, options, query, generatedVariables);
        originals.forEach(function (request) {
          if (!deepEquals(request.result, result)) {
            request.result = result;
            request.setResult(_objectSpread(_objectSpread({}, result), {}, {
              refetch: function refetch() {
                client.refetchQueries({
                  include: [query]
                });
              }
            }));
          }
        });
      });
      observedQueries.push(watchedQuery);
    }
  });
};
export var useNodeInfo = function useNodeInfo(variables, options, queryOptions) {
  var _useState = useState({
      loading: true
    }),
    _useState2 = _slicedToArray(_useState, 2),
    result = _useState2[0],
    setResult = _useState2[1];
  var client = useApolloClient();
  if (!schemaResult) {
    client.query({
      query: SCHEMA_FIELDS_QUERY,
      variables: {
        type: 'GqlPublicationInfo'
      }
    }).then(function (_ref2) {
      var data = _ref2.data;
      schemaResult = data;
      scheduleQueue(client);
    });
  }

  // Normalize and memoize request
  var _useMemoRequest = useMemoRequest(variables, queryOptions, options, setResult),
    _useMemoRequest2 = _slicedToArray(_useMemoRequest, 2),
    currentRequest = _useMemoRequest2[0],
    queryHasChanged = _useMemoRequest2[1];
  useEffect(function () {
    queue.push(currentRequest);
    scheduleQueue(client);
    return function () {
      queue.splice(queue.indexOf(currentRequest), 1);
    };
  }, [client, currentRequest]);
  if (queryHasChanged && !result.loading) {
    if ((queryOptions === null || queryOptions === void 0 ? void 0 : queryOptions.fetchPolicy) !== 'no-cache' && (queryOptions === null || queryOptions === void 0 ? void 0 : queryOptions.fetchPolicy) !== 'network-only') {
      var infoQuery = getQuery(currentRequest.variables, schemaResult, currentRequest.options);
      var res = client.readQuery({
        query: infoQuery.query,
        variables: infoQuery.generatedVariables
      });
      if (res) {
        var _result = getResult(res, {}, currentRequest.options, infoQuery.query, infoQuery.generatedVariables);
        setResult(_result);
        return _result;
      }
    }
    setResult({
      loading: true
    });
    return {
      loading: true
    };
  }
  return result;
};
var getResult = function getResult(data, others, options, query, generatedVariables) {
  var node = data && data.jcr && (data.jcr.nodeByPath || data.jcr.nodeById) || null;
  var nodes = data && data.jcr && (data.jcr.nodesByPath || data.jcr.nodesById) || null;
  var result = others;
  if (node) {
    result = _objectSpread(_objectSpread({
      node: decodeResult(node, options)
    }, others), {}, {
      query: query,
      variables: generatedVariables
    });
  }
  if (nodes) {
    result = _objectSpread(_objectSpread({
      nodes: nodes.map(function (n) {
        return decodeResult(n, options);
      })
    }, others), {}, {
      query: query,
      variables: generatedVariables
    });
  }
  return result;
};
var decodeResult = function decodeResult(nodeOrig, options) {
  var node = _objectSpread({}, nodeOrig);
  if (node.site) {
    node.site = _objectSpread({}, node.site);
  }
  if (node && options) {
    if (options.getPermissions) {
      options.getPermissions.forEach(function (name) {
        var res = node[getEncodedPermissionName(name)];
        delete node[getEncodedPermissionName(name)];
        node[name] = res;
      });
    }
    if (options.getSitePermissions) {
      options.getSitePermissions.forEach(function (name) {
        var res = node.site[getEncodedPermissionName(name)];
        delete node.site[getEncodedPermissionName(name)];
        node.site[name] = res;
      });
    }
    if (options.getIsNodeTypes) {
      options.getIsNodeTypes.forEach(function (name) {
        var res = node[getEncodedNodeTypeName(name)];
        delete node[getEncodedNodeTypeName(name)];
        node[name] = res;
      });
    }
    if (options.getMimeType) {
      var nodes = node.resourceChildren.nodes;
      node.mimeType = nodes.length !== 0 && nodes[0].mimeType.value || null;
      delete node.resourceChildren;
    }
  }
  return node;
};
//# sourceMappingURL=useNodeInfo.js.map

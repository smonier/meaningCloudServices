import _toArray from "@babel/runtime/helpers/toArray";
import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import _taggedTemplateLiteral from "@babel/runtime/helpers/taggedTemplateLiteral";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _assertThisInitialized from "@babel/runtime/helpers/assertThisInitialized";
import _inherits from "@babel/runtime/helpers/inherits";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _pt from "prop-types";
var _templateObject;
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-nocheck
import React from 'react';
import { Query } from '@apollo/react-components';
import gql from 'graphql-tag';
import { displayName, nodeCacheRequiredFields, replaceFragmentsInDocument } from "../fragments";
import { PickerItemsFragment } from "./Picker.gql-fragments";
import rfdc from 'rfdc';
import deepEquals from 'fast-deep-equal';
var clone = rfdc();
export var Picker = /*#__PURE__*/function (_React$Component) {
  _inherits(Picker, _React$Component);
  var _super = _createSuper(Picker);
  function Picker(props) {
    var _this;
    _classCallCheck(this, Picker);
    _this = _super.call(this, props);
    var fragments = props.fragments,
      rootPaths = props.rootPaths,
      onOpenItem = props.onOpenItem,
      onSelectItem = props.onSelectItem,
      openPaths = props.openPaths,
      selectedPaths = props.selectedPaths,
      defaultSelectedPaths = props.defaultSelectedPaths,
      onSelectionChange = props.onSelectionChange,
      defaultOpenPaths = props.defaultOpenPaths;
    var resolvedFragments = fragments || [PickerItemsFragment.mixinTypes, PickerItemsFragment.primaryNodeType, PickerItemsFragment.isPublished, displayName];
    _this.query = gql(_templateObject || (_templateObject = _taggedTemplateLiteral(["\n            query PickerQuery($rootPaths:[String!]!, $selectable:[String]!, $openable:[String]!, $openPaths:[String!]!, $types:[String]!) {\n                jcr {\n                    rootNodes:nodesByPath(paths: $rootPaths) {\n                        name\n                        children(typesFilter:{types:$types}, limit:1) {\n                            pageInfo {\n                                nodesCount\n                            }\n                        }\n                        selectable : isNodeType(type: {types:$selectable})\n                        openable : isNodeType(type: {types:$openable})\n                        ... NodeCacheRequiredFields\n                        ... node\n                    },\n                    openNodes:nodesByPath(paths: $openPaths) {\n                        ... NodeCacheRequiredFields\n                        children(typesFilter:{types:$types}) {\n                            nodes {\n                                name\n                                children(typesFilter:{types:$types}, limit:1) {\n                                    pageInfo {\n                                        nodesCount\n                                    }\n                                }\n                                selectable : isNodeType(type: {types:$selectable})\n                                openable : isNodeType(type: {types:$openable})\n                                ... NodeCacheRequiredFields\n                                ... node\n                            }\n                        }\n                    }\n                }\n            }\n        ", ""])), nodeCacheRequiredFields.gql);
    _this.query = replaceFragmentsInDocument(_this.query, resolvedFragments);
    var state = {};
    _this.eventsHandlers = {};
    if (!openPaths) {
      // Uncontrolled mode
      state.isOpenControlled = false;
      state.openPaths = [];
      _this.eventsHandlers.onOpenItem = function (path, open) {
        _this.setState(function (prevState) {
          return {
            openPaths: open ? [].concat(_toConsumableArray(prevState.openPaths), [path]) : prevState.openPaths.filter(function (thispath) {
              return thispath !== path;
            })
          };
        });
      };
      if (defaultOpenPaths) {
        state.openPaths = _this.addPathToOpenPath(defaultOpenPaths, rootPaths, state.openPaths);
      }
    } else {
      state.isOpenControlled = true;
      if (onOpenItem) {
        _this.eventsHandlers.onOpenItem = onOpenItem;
      }
    }
    if (!selectedPaths) {
      // Uncontrolled mode
      state.isSelectControlled = false;
      state.selectedPaths = defaultSelectedPaths ? clone(defaultSelectedPaths) : [];
      // Open selected path if open is uncontrolled
      if (defaultSelectedPaths && !state.isOpenControlled) {
        state.openPaths = _this.addPathToOpenPath(defaultSelectedPaths, rootPaths, state.openPaths);
      }
      _this.eventsHandlers.onSelectItem = function (path, selected, multiple) {
        _this.setState(function (prevState) {
          var newSelectedPaths = selected ? [].concat(_toConsumableArray(multiple ? prevState.selectedPaths : []), [path]) : prevState.selectedPaths.filter(function (thispath) {
            return thispath !== path;
          });
          onSelectionChange(newSelectedPaths);
          return {
            selectedPaths: newSelectedPaths
          };
        });
      };
    } else if (onSelectItem) {
      state.isSelectControlled = true;
      if (onSelectItem) {
        _this.eventsHandlers.onSelectItem = onSelectItem;
      }
    }
    _this.state = state;

    // Binding
    _this.openPaths = _this.openPaths.bind(_assertThisInitialized(_this));
    return _this;
  }
  _createClass(Picker, [{
    key: "getVariables",
    value: function getVariables(selectedPaths, openPaths) {
      var _this$props = this.props,
        rootPaths = _this$props.rootPaths,
        openableTypes = _this$props.openableTypes,
        selectableTypes = _this$props.selectableTypes,
        queryVariables = _this$props.queryVariables;
      var vars = {
        rootPaths: rootPaths,
        types: _toConsumableArray(new Set([].concat(_toConsumableArray(openableTypes), _toConsumableArray(selectableTypes)))),
        selectable: selectableTypes,
        openable: openableTypes,
        openPaths: openPaths
      };
      if (queryVariables) {
        Object.assign(vars, queryVariables);
      }
      return vars;
    }
  }, {
    key: "getPickerEntries",
    value: function getPickerEntries(data, selectedPaths, openPaths) {
      var _this2 = this;
      var pickerEntries = [];
      var nodesById = {};
      var jcr = data.jcr;
      var addNode = function addNode(node, depth, index) {
        var selected = false;
        if (node.selectable) {
          selected = selectedPaths.indexOf(node.path) !== -1;
        }
        var pickerNode = {
          name: node.name,
          path: node.path,
          open: node.openable && openPaths.indexOf(node.path) !== -1,
          selected: selected,
          openable: node.openable,
          selectable: node.selectable,
          depth: depth,
          prefix: '&nbsp;'.repeat(depth * 3),
          node: node,
          hidden: false,
          hasChildren: node.children.pageInfo.nodesCount > 0
        };
        pickerEntries.splice(index, 0, pickerNode);
        nodesById[node.uuid] = pickerNode;
        return pickerNode;
      };
      if (jcr) {
        if (jcr.rootNodes) {
          jcr.rootNodes.forEach(function (rootNode) {
            var root = addNode(rootNode, 0, 0);
            root.hidden = _this2.props.hideRoot || false;
          });
        }
        if (jcr.openNodes) {
          jcr.openNodes.concat().sort(function (a, b) {
            return a.path > b.path ? 1 : b.path > a.path ? -1 : 0;
          }).forEach(function (node) {
            var parent = nodesById[node.uuid];
            if (parent) {
              var parentIndex = pickerEntries.indexOf(parent);
              node.children.nodes.slice().reverse().forEach(function (child) {
                addNode(child, parent.depth + 1, parentIndex + 1);
              });
            }
          });
        }
      }

      // Nodes loaded, fill selection list
      var selectedNodes = pickerEntries.filter(function (node) {
        return node.selected;
      }).map(function (node) {
        return node.node;
      });
      selectedPaths = selectedNodes.map(function (s) {
        return s.path;
      });
      pickerEntries = pickerEntries.filter(function (pickerNode) {
        return !pickerNode.hidden;
      });
      return pickerEntries;
    }
  }, {
    key: "addPathToOpenPath",
    value: function addPathToOpenPath(pathsToOpen, rootPaths, openPaths) {
      pathsToOpen.forEach(function (path) {
        var rootFound = false;
        if (!path.endsWith('/')) {
          path += '/';
        }
        var _path$split = path.split('/'),
          _path$split2 = _toArray(_path$split),
          tail = _path$split2.slice(0);
        tail.reduce(function (acc, it) {
          if (!rootFound) {
            rootPaths.forEach(function (rootPath) {
              rootFound = rootFound || acc.startsWith(rootPath) && rootPath;
            });
          }
          if (rootFound && !openPaths.includes(acc)) {
            openPaths.push(acc);
            if (!openPaths.includes(rootFound)) {
              openPaths.push(rootFound);
            }
          }
          return acc + '/' + it;
        }, '');
      });
      return openPaths;
    }
  }, {
    key: "openPaths",
    value: function openPaths(paths) {
      var _this3 = this;
      if (!(paths instanceof Array)) {
        paths = [paths];
      }
      this.setState(function (prevState) {
        var openPaths = _this3.addPathToOpenPath(paths, _this3.props.rootPaths, prevState.openPaths);
        return {
          openPaths: openPaths
        };
      });
    }
  }, {
    key: "render",
    value: function render() {
      var _this4 = this;
      var selectedPaths = this.state.selectedPaths ? this.state.selectedPaths : this.props.selectedPaths;
      var openPaths = this.state.openPaths || this.props.openPaths;
      var setRefetch = this.props.setRefetch;
      openPaths = clone(openPaths);
      var vars = this.getVariables(selectedPaths, openPaths);
      return /*#__PURE__*/React.createElement(Query, {
        query: this.query,
        variables: vars,
        fetchPolicy: "cache-first"
      }, function (result) {
        var error = result.error,
          loading = result.loading,
          data = result.data,
          refetch = result.refetch;
        if (setRefetch) {
          setRefetch({
            query: _this4.query,
            queryParams: vars,
            refetch: refetch
          });
        }
        var renderProp = _this4.props.children;
        if (_this4.props.onLoading) {
          _this4.props.onLoading(loading);
        }
        if (loading) {
          if (_this4.previousEntries) {
            return renderProp(_objectSpread({
              pickerEntries: _this4.previousEntries,
              loading: loading
            }, _this4.eventsHandlers));
          }
          return renderProp(_objectSpread({
            pickerEntries: [],
            loading: loading
          }, _this4.eventsHandlers));
        }
        if (error) {
          return renderProp(_objectSpread({
            pickerEntries: [],
            error: error,
            loading: loading
          }, _this4.eventsHandlers));
        }
        var pickerEntries = _this4.getPickerEntries(data, selectedPaths, openPaths);
        _this4.previousEntries = pickerEntries;
        return renderProp(_objectSpread({
          pickerEntries: pickerEntries,
          loading: loading
        }, _this4.eventsHandlers));
      });
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(nextProps, prevState) {
      if (prevState.isOpenControlled !== Boolean(nextProps.openPaths) || prevState.isSelectControlled !== Boolean(nextProps.selectedPaths)) {
        console.warn('Cannot change between controlled/uncontrolled modes');
      }
      var newState = {};
      if (prevState.isOpenControlled && !deepEquals(nextProps.openPaths, prevState.openPaths)) {
        newState.openPaths = nextProps.openPaths;
      }
      if (prevState.isSelectControlled && !deepEquals(nextProps.selectedPaths, prevState.selectedPaths)) {
        newState.selectedPaths = nextProps.selectedPaths;
      }
      if (newState.openPaths || newState.selectedPaths) {
        return newState;
      }
      return null;
    }
  }]);
  return Picker;
}(React.Component);
_defineProperty(Picker, "propTypes", {
  /**
       * Optional set of fragments to add to the graphQL query. Can be a string that identify a predefinedFragment or a fragment definition
       */
  fragments: _pt.array,
  /**
       * List of root paths for the picker
       */
  rootPaths: _pt.arrayOf(_pt.string),
  onOpenItem: _pt.func,
  onSelectItem: _pt.func,
  /**
       * List of open folders in controlled mode
       */
  openPaths: _pt.arrayOf(_pt.string),
  /**
       * List of selected path in controlled mode
       */
  selectedPaths: _pt.arrayOf(_pt.string),
  /**
       * Preselected items path (uncontrolled mode)
       */
  defaultSelectedPaths: _pt.arrayOf(_pt.string),
  /**
       * Callback when the selection has changed
       */
  onSelectionChange: _pt.func,
  /**
       * List of folder paths that are open by default (uncontrolled mode)
       */
  defaultOpenPaths: _pt.arrayOf(_pt.string),
  /**
       * List of node types that can be "opened" (folders)
       */
  openableTypes: _pt.arrayOf(_pt.string),
  /**
       * List of node types that can be "selected" (items)
       */
  selectableTypes: _pt.arrayOf(_pt.string),
  onLoading: _pt.func.isRequired,
  /**
       * Optional set of variable to pass to the graphQL query, in order to fulfill fragments needs
       */
  queryVariables: _pt.objectOf(_pt.any),
  hideRoot: _pt.bool,
  /**
       * Optional function which receives refetch function of the Query component when the component is strapped
       */
  setRefetch: _pt.func.isRequired,
  children: _pt.func.isRequired
});
//# sourceMappingURL=Picker.js.map

{"version":3,"file":"230.jahia.1ee725.js","mappings":"8UAEIA,EAAW,IAAIC,IACfC,EAAoB,IAAID,IACxBE,GAAwB,EACxBC,GAAgC,EACpC,SAASC,EAAUC,GACf,OAAOA,EAAOC,QAAQ,UAAW,KAAKC,MAC1C,CAqDA,SAASC,EAAcC,GACnB,IAlDsBC,EAClBC,EACAC,EAgDAC,EAAWT,EAAUK,GACzB,IAAKV,EAASe,IAAID,GAAW,CACzB,IAAIE,GAAS,QAAMN,EAAQ,CACvBN,8BAA+BA,EAC/Ba,6BAA8Bb,IAElC,IAAKY,GAA0B,aAAhBA,EAAOE,KAClB,MAAM,IAAIC,MAAM,iCAEpBnB,EAASoB,IAAIN,EA7BrB,SAAkBO,GACd,IAAIC,EAAU,IAAIC,IAAIF,EAAIR,aAC1BS,EAAQE,SAAQ,SAAUC,GAClBA,EAAKC,YACED,EAAKC,IAChBC,OAAOC,KAAKH,GAAMD,SAAQ,SAAUK,GAChC,IAAIC,EAAQL,EAAKI,GACbC,GAA0B,iBAAVA,GAChBR,EAAQS,IAAID,EAEpB,GACJ,IACA,IAAIJ,EAAML,EAAIK,IAKd,OAJIA,WACOA,EAAIM,kBACJN,EAAIO,UAERZ,CACX,CAW+Ba,EA3DLvB,EA2D+BK,EA1DjDJ,EAAW,IAAIW,IACfV,EAAc,GAClBF,EAAIE,YAAYW,SAAQ,SAAUW,GAC9B,GAAgC,uBAA5BA,EAAmBjB,KAA+B,CAClD,IAAIkB,EAAeD,EAAmBE,KAAKP,MACvCQ,EARLjC,GADcqB,EASmBS,EAAmBT,KARtChB,OAAO6B,KAAKC,UAAUd,EAAIe,MAAOf,EAAIgB,MAS9CC,EAAezC,EAAkB0C,IAAIR,GACrCO,IAAiBA,EAAa5B,IAAIuB,GAC9BnC,GACA0C,QAAQC,KAAK,+BAAiCV,EAAjC,iMAKXO,GACNzC,EAAkBkB,IAAIgB,EAAcO,EAAe,IAAIpB,KAE3DoB,EAAaZ,IAAIO,GACZ1B,EAASG,IAAIuB,KACd1B,EAASmB,IAAIO,GACbzB,EAAYkC,KAAKZ,GAEzB,MAEItB,EAAYkC,KAAKZ,GA5B7B,IAAyBT,CA8BrB,KACO,SAAS,QAAS,CAAC,EAAGf,GAAM,CAAEE,YAAaA,MAgClD,CACA,OAAOb,EAAS4C,IAAI9B,EACxB,CACO,SAASkC,EAAIC,GAEhB,IADA,IAAIC,EAAO,GACFC,EAAK,EAAGA,EAAKC,UAAUC,OAAQF,IACpCD,EAAKC,EAAK,GAAKC,UAAUD,GAEL,iBAAbF,IACPA,EAAW,CAACA,IAEhB,IAAIK,EAASL,EAAS,GAUtB,OATAC,EAAK1B,SAAQ,SAAU+B,EAAKC,GACpBD,GAAoB,aAAbA,EAAIrC,KACXoC,GAAUC,EAAI7B,IAAIhB,OAAO6B,KAGzBe,GAAUC,EAEdD,GAAUL,EAASO,EAAI,EAC3B,IACO/C,EAAc6C,EACzB,CACO,SAASG,IACZzD,EAAS0D,QACTxD,EAAkBwD,OACtB,CACO,SAASC,IACZxD,GAAwB,CAC5B,CACO,SAASyD,IACZxD,GAAgC,CACpC,CACO,SAASyD,IACZzD,GAAgC,CACpC,CACA,IAOW0D,EAPPC,EACKf,EADLe,EAEaN,EAFbM,EAGyBJ,EAHzBI,EAIqCH,EAJrCG,EAKsCF,GAE/BC,EAERd,IAAQA,EAAM,CAAC,IADRA,IAAMe,EAAYD,EAAML,YAAcM,EAAoBD,EAAMH,wBAA0BI,EAAgCD,EAAMF,oCAAsCG,EAA4CD,EAAMD,qCAAuCE,EAEzQf,EAAa,QAAIA,EACjB,S","sources":["webpack://@jahia/meaningCloudServices/./node_modules/graphql-tag/lib/index.js"],"sourcesContent":["import { __assign } from \"tslib\";\nimport { parse } from 'graphql';\nvar docCache = new Map();\nvar fragmentSourceMap = new Map();\nvar printFragmentWarnings = true;\nvar experimentalFragmentVariables = false;\nfunction normalize(string) {\n    return string.replace(/[\\s,]+/g, ' ').trim();\n}\nfunction cacheKeyFromLoc(loc) {\n    return normalize(loc.source.body.substring(loc.start, loc.end));\n}\nfunction processFragments(ast) {\n    var seenKeys = new Set();\n    var definitions = [];\n    ast.definitions.forEach(function (fragmentDefinition) {\n        if (fragmentDefinition.kind === 'FragmentDefinition') {\n            var fragmentName = fragmentDefinition.name.value;\n            var sourceKey = cacheKeyFromLoc(fragmentDefinition.loc);\n            var sourceKeySet = fragmentSourceMap.get(fragmentName);\n            if (sourceKeySet && !sourceKeySet.has(sourceKey)) {\n                if (printFragmentWarnings) {\n                    console.warn(\"Warning: fragment with name \" + fragmentName + \" already exists.\\n\"\n                        + \"graphql-tag enforces all fragment names across your application to be unique; read more about\\n\"\n                        + \"this in the docs: http://dev.apollodata.com/core/fragments.html#unique-names\");\n                }\n            }\n            else if (!sourceKeySet) {\n                fragmentSourceMap.set(fragmentName, sourceKeySet = new Set);\n            }\n            sourceKeySet.add(sourceKey);\n            if (!seenKeys.has(sourceKey)) {\n                seenKeys.add(sourceKey);\n                definitions.push(fragmentDefinition);\n            }\n        }\n        else {\n            definitions.push(fragmentDefinition);\n        }\n    });\n    return __assign(__assign({}, ast), { definitions: definitions });\n}\nfunction stripLoc(doc) {\n    var workSet = new Set(doc.definitions);\n    workSet.forEach(function (node) {\n        if (node.loc)\n            delete node.loc;\n        Object.keys(node).forEach(function (key) {\n            var value = node[key];\n            if (value && typeof value === 'object') {\n                workSet.add(value);\n            }\n        });\n    });\n    var loc = doc.loc;\n    if (loc) {\n        delete loc.startToken;\n        delete loc.endToken;\n    }\n    return doc;\n}\nfunction parseDocument(source) {\n    var cacheKey = normalize(source);\n    if (!docCache.has(cacheKey)) {\n        var parsed = parse(source, {\n            experimentalFragmentVariables: experimentalFragmentVariables,\n            allowLegacyFragmentVariables: experimentalFragmentVariables\n        });\n        if (!parsed || parsed.kind !== 'Document') {\n            throw new Error('Not a valid GraphQL document.');\n        }\n        docCache.set(cacheKey, stripLoc(processFragments(parsed)));\n    }\n    return docCache.get(cacheKey);\n}\nexport function gql(literals) {\n    var args = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        args[_i - 1] = arguments[_i];\n    }\n    if (typeof literals === 'string') {\n        literals = [literals];\n    }\n    var result = literals[0];\n    args.forEach(function (arg, i) {\n        if (arg && arg.kind === 'Document') {\n            result += arg.loc.source.body;\n        }\n        else {\n            result += arg;\n        }\n        result += literals[i + 1];\n    });\n    return parseDocument(result);\n}\nexport function resetCaches() {\n    docCache.clear();\n    fragmentSourceMap.clear();\n}\nexport function disableFragmentWarnings() {\n    printFragmentWarnings = false;\n}\nexport function enableExperimentalFragmentVariables() {\n    experimentalFragmentVariables = true;\n}\nexport function disableExperimentalFragmentVariables() {\n    experimentalFragmentVariables = false;\n}\nvar extras = {\n    gql: gql,\n    resetCaches: resetCaches,\n    disableFragmentWarnings: disableFragmentWarnings,\n    enableExperimentalFragmentVariables: enableExperimentalFragmentVariables,\n    disableExperimentalFragmentVariables: disableExperimentalFragmentVariables\n};\n(function (gql_1) {\n    gql_1.gql = extras.gql, gql_1.resetCaches = extras.resetCaches, gql_1.disableFragmentWarnings = extras.disableFragmentWarnings, gql_1.enableExperimentalFragmentVariables = extras.enableExperimentalFragmentVariables, gql_1.disableExperimentalFragmentVariables = extras.disableExperimentalFragmentVariables;\n})(gql || (gql = {}));\ngql[\"default\"] = gql;\nexport default gql;\n//# sourceMappingURL=index.js.map"],"names":["docCache","Map","fragmentSourceMap","printFragmentWarnings","experimentalFragmentVariables","normalize","string","replace","trim","parseDocument","source","ast","seenKeys","definitions","cacheKey","has","parsed","allowLegacyFragmentVariables","kind","Error","set","doc","workSet","Set","forEach","node","loc","Object","keys","key","value","add","startToken","endToken","stripLoc","fragmentDefinition","fragmentName","name","sourceKey","body","substring","start","end","sourceKeySet","get","console","warn","push","gql","literals","args","_i","arguments","length","result","arg","i","resetCaches","clear","disableFragmentWarnings","enableExperimentalFragmentVariables","disableExperimentalFragmentVariables","gql_1","extras"],"sourceRoot":""}